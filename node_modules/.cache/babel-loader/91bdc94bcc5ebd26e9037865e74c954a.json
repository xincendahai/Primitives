{"ast":null,"code":"// 标尺中每小格代表的宽度(根据scale的不同实时变化)\nvar getGridSize = function getGridSize(scale) {\n  if (scale <= 0.25) return 40;\n  if (scale <= 0.5) return 20;\n  if (scale <= 1) return 10;\n  if (scale <= 2) return 5;\n  if (scale <= 4) return 2;\n  return 1;\n};\n\nvar FONT_SCALE = 0.83; // 10 / 12\n\nexport var drawHorizontalRuler = function drawHorizontalRuler(ctx, start, shadow, options) {\n  var scale = options.scale,\n      width = options.width,\n      height = options.height,\n      canvasConfigs = options.canvasConfigs;\n  var bgColor = canvasConfigs.bgColor,\n      fontColor = canvasConfigs.fontColor,\n      shadowColor = canvasConfigs.shadowColor,\n      ratio = canvasConfigs.ratio,\n      longfgColor = canvasConfigs.longfgColor,\n      shortfgColor = canvasConfigs.shortfgColor; // 缩放ctx, 以简化计算\n\n  ctx.scale(ratio, ratio);\n  ctx.clearRect(0, 0, width, height); // 1. 画标尺底色\n\n  ctx.fillStyle = bgColor;\n  ctx.fillRect(0, 0, width, height); // 2. 画阴影\n\n  if (shadow) {\n    var shadowX = (shadow.x - start) * scale; // 阴影起点坐标\n\n    var shadowWidth = shadow.width * scale; // 阴影宽度\n\n    ctx.fillStyle = shadowColor;\n    ctx.fillRect(shadowX, 0, shadowWidth, height * 3 / 8);\n  }\n\n  var gridSize = getGridSize(scale); // 每小格表示的宽度\n\n  var gridPixel = gridSize * scale;\n  var gridSize_10 = gridSize * 10; // 每大格表示的宽度\n\n  var gridPixel_10 = gridSize_10 * scale;\n  var startValue = Math.floor(start / gridSize) * gridSize; // 绘制起点的刻度(略小于start, 且是gridSize的整数倍)\n\n  var startValue_10 = Math.floor(start / gridSize_10) * gridSize_10; // 长间隔绘制起点的刻度(略小于start, 且是gridSize_10的整数倍)\n\n  var offsetX = (startValue - start) / gridSize * gridPixel; // 起点刻度距离ctx原点(start)的px距离\n\n  var offsetX_10 = (startValue_10 - start) / gridSize_10 * gridPixel_10; // 长间隔起点刻度距离ctx原点(start)的px距离\n\n  var endValue = start + Math.ceil(width / scale); // 终点刻度(略超出标尺宽度即可)\n  // 3. 画刻度和文字(因为刻度遮住了阴影)\n\n  ctx.beginPath(); // 一定要记得开关路径,因为clearRect并不能清除掉路径,如果不关闭路径下次绘制时会接着上次的绘制\n\n  ctx.fillStyle = fontColor;\n  ctx.strokeStyle = longfgColor; // 长间隔和短间隔需要两次绘制，才可以完成不同颜色的设置；分开放到两个for循环是为了节省性能，因为如果放到一个for循环的话，每次循环都会重新绘制操作dom\n  // 绘制长间隔和文字\n\n  for (var value = startValue_10, count = 0; value < endValue; value += gridSize_10, count++) {\n    var x = offsetX_10 + count * gridPixel_10 + 0.5; // prevent canvas 1px line blurry\n\n    ctx.moveTo(x, 0);\n    ctx.save();\n    ctx.translate(x, height * 0.4);\n    ctx.scale(FONT_SCALE / ratio, FONT_SCALE / ratio);\n    ctx.fillText(value, 4 * ratio, 7 * ratio);\n    ctx.restore();\n    ctx.lineTo(x, height * 9 / 16);\n  }\n\n  ctx.stroke();\n  ctx.closePath(); // 绘制短间隔\n\n  ctx.beginPath();\n  ctx.strokeStyle = shortfgColor;\n\n  for (var _value = startValue, _count = 0; _value < endValue; _value += gridSize, _count++) {\n    var _x = offsetX + _count * gridPixel + 0.5; // prevent canvas 1px line blurry\n\n\n    ctx.moveTo(_x, 0);\n\n    if (_value % gridSize_10 !== 0) {\n      ctx.lineTo(_x, height * 1 / 4);\n    }\n  }\n\n  ctx.stroke();\n  ctx.closePath(); // 恢复ctx matrix\n\n  ctx.setTransform(1, 0, 0, 1, 0, 0);\n};\nexport var drawVerticalRuler = function drawVerticalRuler(ctx, start, shadow, options) {\n  var scale = options.scale,\n      width = options.width,\n      height = options.height,\n      canvasConfigs = options.canvasConfigs;\n  var bgColor = canvasConfigs.bgColor,\n      fontColor = canvasConfigs.fontColor,\n      shadowColor = canvasConfigs.shadowColor,\n      ratio = canvasConfigs.ratio,\n      longfgColor = canvasConfigs.longfgColor,\n      shortfgColor = canvasConfigs.shortfgColor; // 缩放ctx, 以简化计算\n\n  ctx.scale(ratio, ratio);\n  ctx.clearRect(0, 0, width, height); // 1. 画标尺底色\n\n  ctx.fillStyle = bgColor;\n  ctx.fillRect(0, 0, width, height); // 2. 画阴影\n\n  if (shadow) {\n    // 阴影起点坐标\n    var posY = (shadow.y - start) * scale; // 阴影高度\n\n    var shadowHeight = shadow.height * scale;\n    ctx.fillStyle = shadowColor;\n    ctx.fillRect(0, posY, width * 3 / 8, shadowHeight);\n  }\n\n  var gridSize = getGridSize(scale); // 每小格表示的宽度\n\n  var gridPixel = gridSize * scale;\n  var gridSize_10 = gridSize * 10; // 每大格表示的宽度\n\n  var gridPixel_10 = gridSize_10 * scale;\n  var startValue = Math.floor(start / gridSize) * gridSize; // 绘制起点的刻度(略小于start, 且是gridSize的整数倍)\n\n  var startValue_10 = Math.floor(start / gridSize_10) * gridSize_10; // 长间隔单独绘制起点的刻度\n\n  var offsetY = (startValue - start) / gridSize * gridPixel; // 起点刻度距离ctx原点(start)的px距离\n\n  var offsetY_10 = (startValue_10 - start) / gridSize_10 * gridPixel_10; // 长间隔起点刻度距离ctx原点(start)的px距离\n\n  var endValue = start + Math.ceil(height / scale); // 终点刻度(略超出标尺宽度即可)\n  // 3. 画刻度和文字(因为刻度遮住了阴影)\n\n  ctx.beginPath(); // 一定要记得开关路径,因为clearRect并不能清除掉路径,如果不关闭路径下次绘制时会接着上次的绘制\n\n  ctx.fillStyle = fontColor;\n  ctx.strokeStyle = longfgColor; // 设置长间隔的颜色\n\n  for (var value = startValue_10, count = 0; value < endValue; value += gridSize_10, count++) {\n    var y = offsetY_10 + count * gridPixel_10 + 0.5;\n    ctx.moveTo(0, y);\n    ctx.save(); // 这里先保存一下状态\n\n    ctx.translate(width * 0.4, y); // 将原点转移到当前画笔所在点\n\n    ctx.rotate(-Math.PI / 2); // 旋转 -90 度\n\n    ctx.scale(FONT_SCALE / ratio, FONT_SCALE / ratio); // 缩放至10px\n\n    ctx.fillText(value, 4 * ratio, 7 * ratio); // 绘制文字\n    // 回复刚刚保存的状态\n\n    ctx.restore();\n    ctx.lineTo(width * 9 / 16, y);\n  }\n\n  ctx.stroke(); // 绘制\n\n  ctx.closePath(); // 长间隔和文字绘制关闭\n\n  ctx.beginPath(); // 开始绘制短间隔\n\n  ctx.strokeStyle = shortfgColor;\n\n  for (var _value2 = startValue, _count2 = 0; _value2 < endValue; _value2 += gridSize, _count2++) {\n    var _y = offsetY + _count2 * gridPixel + 0.5;\n\n    ctx.moveTo(0, _y);\n\n    if (_value2 % gridSize_10 !== 0) {\n      ctx.lineTo(width * 1 / 4, _y);\n    }\n  }\n\n  ctx.stroke();\n  ctx.closePath(); // 恢复ctx matrix\n\n  ctx.setTransform(1, 0, 0, 1, 0, 0);\n};","map":{"version":3,"sources":["/Users/xiangmingxin/Wicrecend/图元/react-visual-data/src/components/sketch-ruler/utils.js"],"names":["getGridSize","scale","FONT_SCALE","drawHorizontalRuler","ctx","start","shadow","options","width","height","canvasConfigs","bgColor","fontColor","shadowColor","ratio","longfgColor","shortfgColor","clearRect","fillStyle","fillRect","shadowX","x","shadowWidth","gridSize","gridPixel","gridSize_10","gridPixel_10","startValue","Math","floor","startValue_10","offsetX","offsetX_10","endValue","ceil","beginPath","strokeStyle","value","count","moveTo","save","translate","fillText","restore","lineTo","stroke","closePath","setTransform","drawVerticalRuler","posY","y","shadowHeight","offsetY","offsetY_10","rotate","PI"],"mappings":"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","sourcesContent":["// 标尺中每小格代表的宽度(根据scale的不同实时变化)\nconst getGridSize = (scale) => {\n  if (scale <= 0.25) return 40;\n  if (scale <= 0.5) return 20;\n  if (scale <= 1) return 10;\n  if (scale <= 2) return 5;\n  if (scale <= 4) return 2;\n  return 1;\n};\n\nconst FONT_SCALE = 0.83; // 10 / 12\n\nexport const drawHorizontalRuler = (ctx, start, shadow, options) => {\n  const { scale, width, height, canvasConfigs } = options;\n  const { bgColor, fontColor, shadowColor, ratio, longfgColor, shortfgColor } = canvasConfigs;\n\n  // 缩放ctx, 以简化计算\n  ctx.scale(ratio, ratio);\n  ctx.clearRect(0, 0, width, height);\n\n  // 1. 画标尺底色\n  ctx.fillStyle = bgColor;\n  ctx.fillRect(0, 0, width, height);\n\n  // 2. 画阴影\n  if (shadow) {\n    const shadowX = (shadow.x - start) * scale; // 阴影起点坐标\n    const shadowWidth = shadow.width * scale; // 阴影宽度\n    ctx.fillStyle = shadowColor;\n    ctx.fillRect(shadowX, 0, shadowWidth, (height * 3) / 8);\n  }\n\n  const gridSize = getGridSize(scale); // 每小格表示的宽度\n  const gridPixel = gridSize * scale;\n  const gridSize_10 = gridSize * 10; // 每大格表示的宽度\n  const gridPixel_10 = gridSize_10 * scale;\n\n  const startValue = Math.floor(start / gridSize) * gridSize; // 绘制起点的刻度(略小于start, 且是gridSize的整数倍)\n  const startValue_10 = Math.floor(start / gridSize_10) * gridSize_10; // 长间隔绘制起点的刻度(略小于start, 且是gridSize_10的整数倍)\n\n  const offsetX = ((startValue - start) / gridSize) * gridPixel; // 起点刻度距离ctx原点(start)的px距离\n  const offsetX_10 = ((startValue_10 - start) / gridSize_10) * gridPixel_10; // 长间隔起点刻度距离ctx原点(start)的px距离\n  const endValue = start + Math.ceil(width / scale); // 终点刻度(略超出标尺宽度即可)\n\n  // 3. 画刻度和文字(因为刻度遮住了阴影)\n  ctx.beginPath(); // 一定要记得开关路径,因为clearRect并不能清除掉路径,如果不关闭路径下次绘制时会接着上次的绘制\n\n  ctx.fillStyle = fontColor;\n  ctx.strokeStyle = longfgColor;\n\n  // 长间隔和短间隔需要两次绘制，才可以完成不同颜色的设置；分开放到两个for循环是为了节省性能，因为如果放到一个for循环的话，每次循环都会重新绘制操作dom\n  // 绘制长间隔和文字\n  for (let value = startValue_10, count = 0; value < endValue; value += gridSize_10, count++) {\n    const x = offsetX_10 + count * gridPixel_10 + 0.5; // prevent canvas 1px line blurry\n    ctx.moveTo(x, 0);\n    ctx.save();\n    ctx.translate(x, height * 0.4);\n    ctx.scale(FONT_SCALE / ratio, FONT_SCALE / ratio);\n    ctx.fillText(value, 4 * ratio, 7 * ratio);\n    ctx.restore();\n    ctx.lineTo(x, (height * 9) / 16);\n  }\n  ctx.stroke();\n  ctx.closePath();\n\n  // 绘制短间隔\n  ctx.beginPath();\n  ctx.strokeStyle = shortfgColor;\n  for (let value = startValue, count = 0; value < endValue; value += gridSize, count++) {\n    const x = offsetX + count * gridPixel + 0.5; // prevent canvas 1px line blurry\n    ctx.moveTo(x, 0);\n    if (value % gridSize_10 !== 0) {\n      ctx.lineTo(x, (height * 1) / 4);\n    }\n  }\n  ctx.stroke();\n  ctx.closePath();\n\n  // 恢复ctx matrix\n  ctx.setTransform(1, 0, 0, 1, 0, 0);\n};\n\nexport const drawVerticalRuler = (ctx, start, shadow, options) => {\n  const { scale, width, height, canvasConfigs } = options;\n  const { bgColor, fontColor, shadowColor, ratio, longfgColor, shortfgColor } = canvasConfigs;\n\n  // 缩放ctx, 以简化计算\n  ctx.scale(ratio, ratio);\n  ctx.clearRect(0, 0, width, height);\n\n  // 1. 画标尺底色\n  ctx.fillStyle = bgColor;\n  ctx.fillRect(0, 0, width, height);\n\n  // 2. 画阴影\n  if (shadow) {\n    // 阴影起点坐标\n    const posY = (shadow.y - start) * scale;\n    // 阴影高度\n    const shadowHeight = shadow.height * scale;\n    ctx.fillStyle = shadowColor;\n    ctx.fillRect(0, posY, (width * 3) / 8, shadowHeight);\n  }\n\n  const gridSize = getGridSize(scale); // 每小格表示的宽度\n  const gridPixel = gridSize * scale;\n  const gridSize_10 = gridSize * 10; // 每大格表示的宽度\n  const gridPixel_10 = gridSize_10 * scale;\n\n  const startValue = Math.floor(start / gridSize) * gridSize; // 绘制起点的刻度(略小于start, 且是gridSize的整数倍)\n  const startValue_10 = Math.floor(start / gridSize_10) * gridSize_10; // 长间隔单独绘制起点的刻度\n\n  const offsetY = ((startValue - start) / gridSize) * gridPixel; // 起点刻度距离ctx原点(start)的px距离\n  const offsetY_10 = ((startValue_10 - start) / gridSize_10) * gridPixel_10; // 长间隔起点刻度距离ctx原点(start)的px距离\n  const endValue = start + Math.ceil(height / scale); // 终点刻度(略超出标尺宽度即可)\n\n  // 3. 画刻度和文字(因为刻度遮住了阴影)\n  ctx.beginPath(); // 一定要记得开关路径,因为clearRect并不能清除掉路径,如果不关闭路径下次绘制时会接着上次的绘制\n\n  ctx.fillStyle = fontColor;\n  ctx.strokeStyle = longfgColor; // 设置长间隔的颜色\n\n  for (let value = startValue_10, count = 0; value < endValue; value += gridSize_10, count++) {\n    const y = offsetY_10 + count * gridPixel_10 + 0.5;\n    ctx.moveTo(0, y);\n    ctx.save(); // 这里先保存一下状态\n    ctx.translate(width * 0.4, y); // 将原点转移到当前画笔所在点\n    ctx.rotate(-Math.PI / 2); // 旋转 -90 度\n    ctx.scale(FONT_SCALE / ratio, FONT_SCALE / ratio); // 缩放至10px\n    ctx.fillText(value, 4 * ratio, 7 * ratio); // 绘制文字\n    // 回复刚刚保存的状态\n    ctx.restore();\n    ctx.lineTo((width * 9) / 16, y);\n  }\n  ctx.stroke(); // 绘制\n  ctx.closePath(); // 长间隔和文字绘制关闭\n\n  ctx.beginPath(); // 开始绘制短间隔\n  ctx.strokeStyle = shortfgColor;\n\n  for (let value = startValue, count = 0; value < endValue; value += gridSize, count++) {\n    const y = offsetY + count * gridPixel + 0.5;\n    ctx.moveTo(0, y);\n    if (value % gridSize_10 !== 0) {\n      ctx.lineTo((width * 1) / 4, y);\n    }\n  }\n  ctx.stroke();\n  ctx.closePath();\n\n  // 恢复ctx matrix\n  ctx.setTransform(1, 0, 0, 1, 0, 0);\n};\n"]},"metadata":{},"sourceType":"module"}